
#pragma once

#include "RenderTypes.h"

// TODO(Matt): Move most of these vars into an ini file or something.
// TODO(Matt): Whip up a heap alloc'd array, or grab stb stretchybuffer.
// There's a lot of easy to leak heap memory in here.
#define MAX_FRAMES_IN_FLIGHT 2

// Stores vulkan information that must be recreated with the swapchain.
struct SwapchainInfo
{
    VkSwapchainKHR swapchain;
    uint32_t image_count;
    VkSurfaceFormatKHR format;
    VkPresentModeKHR present_mode;
    VkExtent2D extent;
    VkSurfaceTransformFlagBitsKHR transform;
    VkRenderPass renderpass;
    uint32_t current_frame;
    uint32_t pipeline_count;
    VkImage color_image;
    VkDeviceMemory color_image_memory;
    VkImageView color_image_view;
    VkImage depth_image;
    VkDeviceMemory depth_image_memory;
    VkImageView depth_image_view;
    VkFormat depth_format;
    
    // Heap allocated (make sure they get freed):
    VkPipelineLayout *pipeline_layouts;
    VkPipeline *pipelines;
    VkFramebuffer *framebuffers;
    VkImage *images;
    VkImageView *imageviews;
    VkCommandBuffer *primary_command_buffers;
};

struct MaterialCreateInfo
{
    VkPipelineVertexInputStateCreateInfo input_info;
    VkVertexInputBindingDescription binding_description;
    VkVertexInputAttributeDescription attribute_descriptions[6];
    VkPipelineInputAssemblyStateCreateInfo assembly_info;
    VkViewport viewport;
    VkPipelineViewportStateCreateInfo viewport_info;
    VkRect2D scissor;
    VkPipelineRasterizationStateCreateInfo raster_info;
    VkPipelineMultisampleStateCreateInfo multisample_info;
    VkPipelineColorBlendAttachmentState blend;
    VkPipelineColorBlendStateCreateInfo blend_info;
    VkPipelineDepthStencilStateCreateInfo depth_stencil;
    VkPipelineShaderStageCreateInfo *shader_stages;
    VkShaderModule *shader_modules;
    uint32_t stage_count;
};


struct Material
{
    VkPipeline pipeline;
    uint32_t type;
    Model *models;
};

struct MaterialLayout
{
    VkPipelineLayout pipeline_layout;
    VkDescriptorSetLayout *descriptor_layouts;
    Material *materials;
};


// Reads a shader file as a heap allocated byte array.
// TODO(Matt): Merge me with the shader module creation, to simplify the usage code.
char *ReadShaderFile(const char *path, uint32_t *length);

void InitializeRenderer();
void ShutdownRenderer();

// Draw the next frame.
void DrawFrame();

void CreateModelBuffer(VkDeviceSize buffer_size, void* buffer_data, VkBuffer* buffer, VkDeviceMemory* buffer_memory);
void CreateModelUniformBuffers(VkDeviceSize buffer_size, VkBuffer* uniform_buffers, VkDeviceMemory* uniform_buffers_memory, uint32_t uniform_count);
void CreateModelDescriptorSets(uint32_t uniform_count, uint32_t material_type, uint32_t shader_id, VkBuffer* uniform_buffers, VkDescriptorSet *descriptor_sets);

void CreateVertexBuffer(Model *model);
void CreateIndexBuffer(Model *model);
void CreateUniformBuffers(Model *model);
void CreateDescriptorSets(Model *model);

void OnWindowResized();
void UpdateUniforms(uint32_t image_index, Model *model);

void SelectObject(int32_t mouse_x, int32_t mouse_y, bool accumulate);

void RecordPrimaryCommand(uint32_t image_index);
void UpdateModels(double frame_delta);

// Sets up a pipeline create info with defaults. Pass nullptr for fragment
// code if not needed.
MaterialCreateInfo CreateDefaultMaterialInfo(const char *vert_file, const char *frag_file);

// Creates a graphics pipeline from create info generated by a call
// to CreateDefaultPipelineInfo().
void AddMaterial(MaterialCreateInfo *material_info, uint32_t material_type, VkRenderPass render_pass, uint32_t sub_pass);

MaterialLayout CreateMaterialLayout();

void CreateMaterials();
void DestroyMaterials();
void InitializeScene();
void AddToScene(Model model);
void DestroyScene();